create extension if not exists pg_trgm;

create table if not exists public.sponsors (
  id bigint generated by default as identity primary key,
  name_original text not null,
  name_normalized text not null,
  sponsor_type text,
  route text,
  register_url text,
  last_updated date not null
);

create index if not exists sponsors_name_normalized_trgm_idx
  on public.sponsors
  using gin (name_normalized gin_trgm_ops);

create unique index if not exists sponsors_name_unique_idx
  on public.sponsors (name_original, sponsor_type, route);

alter table public.sponsors enable row level security;

create policy "Public read access" on public.sponsors
  for select
  using (true);

create or replace function public.normalize_company_name(input text)
returns text
language plpgsql
immutable
as $$
declare
  cleaned text;
begin
  cleaned := lower(coalesce(input, ''));
  cleaned := regexp_replace(cleaned, '[^a-z0-9\s]', ' ', 'g');
  cleaned := regexp_replace(cleaned, '\s+', ' ', 'g');
  cleaned := btrim(cleaned);

  cleaned := regexp_replace(cleaned, '\b(limited|ltd|plc|llp|inc|co|corp|company|group|holdings|the)\b', '', 'g');
  cleaned := regexp_replace(cleaned, '\s+', ' ', 'g');
  cleaned := btrim(cleaned);

  return cleaned;
end;
$$;

create or replace function public.search_sponsors(
  query text,
  limit_count int default 5,
  similarity_threshold float default 0.82
)
returns table(
  match_type text,
  score float,
  name_original text,
  sponsor_type text,
  register_url text,
  last_updated date
)
language plpgsql
stable
as $$
declare
  q text := public.normalize_company_name(query);
begin
  if q = '' then
    return;
  end if;

  return query
  select
    case
      when s.name_normalized = q then 'exact'
      else 'fuzzy'
    end as match_type,
    case
      when s.name_normalized = q then 1.0
      else similarity(s.name_normalized, q)
    end as score,
    s.name_original,
    s.sponsor_type,
    s.register_url,
    s.last_updated
  from public.sponsors s
  where s.last_updated = (select max(s2.last_updated) from public.sponsors s2)
    and (s.name_normalized = q
     or similarity(s.name_normalized, q) >= similarity_threshold)
  order by
    (s.name_normalized = q) desc,
    similarity(s.name_normalized, q) desc
  limit limit_count;
end;
$$;
